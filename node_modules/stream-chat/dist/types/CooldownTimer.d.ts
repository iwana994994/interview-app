import { StateStore } from './store';
import { WithSubscriptions } from './utils/WithSubscriptions';
import type { Channel } from './channel';
export type CooldownTimerState = {
    /**
     * Slow mode cooldown interval in seconds. Change reported via channel.updated WS event.
     */
    cooldownConfigSeconds: number;
    /**
     * Whether the current user can skip slow mode. Change is not reported via WS.
     */
    canSkipCooldown: boolean;
    /**
     * Latest message creation date authored by the current user in this channel. Change reported via message.new WS event.
     */
    ownLatestMessageDate?: Date;
    /**
     * Remaining cooldown in whole seconds (rounded).
     */
    cooldownRemaining: number;
};
export declare class CooldownTimer extends WithSubscriptions {
    readonly state: StateStore<CooldownTimerState>;
    private timeout;
    private channel;
    constructor({ channel }: {
        channel: Channel;
    });
    get cooldownConfigSeconds(): number;
    get cooldownRemaining(): number;
    get canSkipCooldown(): boolean;
    get ownLatestMessageDate(): Date | undefined;
    registerSubscriptions: () => void;
    setCooldownRemaining: (cooldownRemaining: number) => void;
    clearTimeout: () => void;
    refresh: () => void;
    /**
     * Updates the known latest own message date and recomputes remaining time.
     * Prefer calling this when you already know the message date (e.g. from an event).
     */
    setOwnLatestMessageDate: (date: Date | undefined) => void;
    private getOwnUserId;
    private findOwnLatestMessageDate;
    private recalculate;
}
